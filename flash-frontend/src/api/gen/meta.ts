/**
 * Generated by orval v6.15.0 üç∫
 * Do not edit manually.
 * xSwap Meta API
 * xSwap Meta service API
 * OpenAPI spec version: v2.0.0
 */
import { useQuery } from '@tanstack/react-query';
import type { QueryFunction, QueryKey, UseQueryOptions, UseQueryResult } from '@tanstack/react-query';

import { clientMeta } from '../clients';
import type { ErrorType } from '../clients';

export type GetBalanceDictMetaParams = {
  addresses?: string[];
  by?: BalanceDictKeySegmentMeta[];
  glue?: BalanceDictKeyGlueMeta;
};

export type GetBalanceListMetaParams = {
  addresses?: string[];
};

export type GetPriceListMetaParams = {
  fiat?: string;
};

export type GetFiatListMetaParams = {
  fiats?: string[];
};

export type ValidationErrorMetaLocItem = string | number;

export interface ValidationErrorMeta {
  loc: ValidationErrorMetaLocItem[];
  msg: string;
  type: string;
}

export interface PriceListMeta {
  fiat: FiatInfoMeta;
  prices: PriceInfoMeta[];
}

/**
 * An enumeration.
 */
export type PriceDictKeySegmentMeta = (typeof PriceDictKeySegmentMeta)[keyof typeof PriceDictKeySegmentMeta];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PriceDictKeySegmentMeta = {
  chain_id: 'chain_id',
  address: 'address',
} as const;

/**
 * An enumeration.
 */
export type PriceDictKeyGlueMeta = (typeof PriceDictKeyGlueMeta)[keyof typeof PriceDictKeyGlueMeta];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PriceDictKeyGlueMeta = {
  slash: 'slash',
  colon: 'colon',
  plus: 'plus',
  minus: 'minus',
} as const;

export type GetPriceDictMetaParams = {
  fiat?: string;
  by?: PriceDictKeySegmentMeta[];
  glue?: PriceDictKeyGlueMeta;
};

export type PriceDictMetaPrices = { [key: string]: DecimalAmountMeta };

export interface HTTPValidationErrorMeta {
  detail?: ValidationErrorMeta[];
}

/**
 * An enumeration.
 */
export type FiatFormatMeta = (typeof FiatFormatMeta)[keyof typeof FiatFormatMeta];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const FiatFormatMeta = {
  sign_amount: 'sign_amount',
  amount_sign: 'amount_sign',
} as const;

export interface FiatInfoMeta {
  name: string;
  symbol: string;
  sign: string;
  decimals: number;
  separator: string;
  format: FiatFormatMeta;
}

export interface PriceDictMeta {
  fiat: FiatInfoMeta;
  prices: PriceDictMetaPrices;
}

export interface FiatListMeta {
  fiats: FiatInfoMeta[];
}

export interface DecimalAmountMeta {
  v: string;
  d: number;
}

export interface PriceInfoMeta {
  chain_id: string;
  address: string;
  price: DecimalAmountMeta;
}

export interface BalanceInfoMeta {
  address: string;
  assets: AssetBalanceMeta[];
}

export interface BalanceListMeta {
  balances: BalanceInfoMeta[];
}

/**
 * An enumeration.
 */
export type BalanceDictKeySegmentMeta = (typeof BalanceDictKeySegmentMeta)[keyof typeof BalanceDictKeySegmentMeta];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const BalanceDictKeySegmentMeta = {
  chain_id: 'chain_id',
  address: 'address',
} as const;

/**
 * An enumeration.
 */
export type BalanceDictKeyGlueMeta = (typeof BalanceDictKeyGlueMeta)[keyof typeof BalanceDictKeyGlueMeta];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const BalanceDictKeyGlueMeta = {
  slash: 'slash',
  colon: 'colon',
  plus: 'plus',
  minus: 'minus',
} as const;

export type BalanceDictMetaBalances = { [key: string]: { [key: string]: DecimalAmountMeta } };

export interface BalanceDictMeta {
  balances: BalanceDictMetaBalances;
}

export interface AssetBalanceMeta {
  chain_id: string;
  address: string;
  balance: DecimalAmountMeta;
}

type AwaitedInput<T> = PromiseLike<T> | T;

type Awaited<O> = O extends AwaitedInput<infer T> ? T : never;

// eslint-disable-next-line
type SecondParameter<T extends (...args: any) => any> = T extends (config: any, args: infer P) => any ? P : never;

/**
 * Returns infos of supported fiat
 * @summary Get fiat info
 */
export const getFiatListMeta = (fiat: string, options?: SecondParameter<typeof clientMeta>, signal?: AbortSignal) => {
  return clientMeta<FiatInfoMeta>({ url: `/api/v2/meta/fiats/item/${fiat}`, method: 'get', signal }, options);
};

export const getGetFiatListMetaQueryKey = (fiat: string) => [`/api/v2/meta/fiats/item/${fiat}`] as const;

export const getGetFiatListMetaQueryOptions = <
  TData = Awaited<ReturnType<typeof getFiatListMeta>>,
  TError = ErrorType<HTTPValidationErrorMeta>,
>(
  fiat: string,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof getFiatListMeta>>, TError, TData>;
    request?: SecondParameter<typeof clientMeta>;
  },
): UseQueryOptions<Awaited<ReturnType<typeof getFiatListMeta>>, TError, TData> & { queryKey: QueryKey } => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetFiatListMetaQueryKey(fiat);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getFiatListMeta>>> = ({ signal }) =>
    getFiatListMeta(fiat, requestOptions, signal);

  return { queryKey, queryFn, enabled: !!fiat, ...queryOptions };
};

export type GetFiatListMetaQueryResult = NonNullable<Awaited<ReturnType<typeof getFiatListMeta>>>;
export type GetFiatListMetaQueryError = ErrorType<HTTPValidationErrorMeta>;

export const useGetFiatListMeta = <
  TData = Awaited<ReturnType<typeof getFiatListMeta>>,
  TError = ErrorType<HTTPValidationErrorMeta>,
>(
  fiat: string,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof getFiatListMeta>>, TError, TData>;
    request?: SecondParameter<typeof clientMeta>;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetFiatListMetaQueryOptions(fiat, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Returns list of price infos for all known assets
 * @summary Get price info list
 */
export const getPriceListMeta = (
  params?: GetPriceListMetaParams,
  options?: SecondParameter<typeof clientMeta>,
  signal?: AbortSignal,
) => {
  return clientMeta<PriceListMeta>({ url: `/api/v2/meta/prices/list`, method: 'get', params, signal }, options);
};

export const getGetPriceListMetaQueryKey = (params?: GetPriceListMetaParams) =>
  [`/api/v2/meta/prices/list`, ...(params ? [params] : [])] as const;

export const getGetPriceListMetaQueryOptions = <
  TData = Awaited<ReturnType<typeof getPriceListMeta>>,
  TError = ErrorType<HTTPValidationErrorMeta>,
>(
  params?: GetPriceListMetaParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof getPriceListMeta>>, TError, TData>;
    request?: SecondParameter<typeof clientMeta>;
  },
): UseQueryOptions<Awaited<ReturnType<typeof getPriceListMeta>>, TError, TData> & { queryKey: QueryKey } => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetPriceListMetaQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getPriceListMeta>>> = ({ signal }) =>
    getPriceListMeta(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions };
};

export type GetPriceListMetaQueryResult = NonNullable<Awaited<ReturnType<typeof getPriceListMeta>>>;
export type GetPriceListMetaQueryError = ErrorType<HTTPValidationErrorMeta>;

export const useGetPriceListMeta = <
  TData = Awaited<ReturnType<typeof getPriceListMeta>>,
  TError = ErrorType<HTTPValidationErrorMeta>,
>(
  params?: GetPriceListMetaParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof getPriceListMeta>>, TError, TData>;
    request?: SecondParameter<typeof clientMeta>;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetPriceListMetaQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Returns dict of price infos by specified key for all known assets
 * @summary Get price info dict
 */
export const getPriceDictMeta = (
  params?: GetPriceDictMetaParams,
  options?: SecondParameter<typeof clientMeta>,
  signal?: AbortSignal,
) => {
  return clientMeta<PriceDictMeta>({ url: `/api/v2/meta/prices/dict`, method: 'get', params, signal }, options);
};

export const getGetPriceDictMetaQueryKey = (params?: GetPriceDictMetaParams) =>
  [`/api/v2/meta/prices/dict`, ...(params ? [params] : [])] as const;

export const getGetPriceDictMetaQueryOptions = <
  TData = Awaited<ReturnType<typeof getPriceDictMeta>>,
  TError = ErrorType<HTTPValidationErrorMeta>,
>(
  params?: GetPriceDictMetaParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof getPriceDictMeta>>, TError, TData>;
    request?: SecondParameter<typeof clientMeta>;
  },
): UseQueryOptions<Awaited<ReturnType<typeof getPriceDictMeta>>, TError, TData> & { queryKey: QueryKey } => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetPriceDictMetaQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getPriceDictMeta>>> = ({ signal }) =>
    getPriceDictMeta(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions };
};

export type GetPriceDictMetaQueryResult = NonNullable<Awaited<ReturnType<typeof getPriceDictMeta>>>;
export type GetPriceDictMetaQueryError = ErrorType<HTTPValidationErrorMeta>;

export const useGetPriceDictMeta = <
  TData = Awaited<ReturnType<typeof getPriceDictMeta>>,
  TError = ErrorType<HTTPValidationErrorMeta>,
>(
  params?: GetPriceDictMetaParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof getPriceDictMeta>>, TError, TData>;
    request?: SecondParameter<typeof clientMeta>;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetPriceDictMetaQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Returns list of balances of specified addresses for all supported tokens and blockchains
 * @summary Get balance list
 */
export const getBalanceListMeta = (
  params?: GetBalanceListMetaParams,
  options?: SecondParameter<typeof clientMeta>,
  signal?: AbortSignal,
) => {
  return clientMeta<BalanceListMeta>({ url: `/api/v2/meta/balances/list`, method: 'get', params, signal }, options);
};

export const getGetBalanceListMetaQueryKey = (params?: GetBalanceListMetaParams) =>
  [`/api/v2/meta/balances/list`, ...(params ? [params] : [])] as const;

export const getGetBalanceListMetaQueryOptions = <
  TData = Awaited<ReturnType<typeof getBalanceListMeta>>,
  TError = ErrorType<HTTPValidationErrorMeta>,
>(
  params?: GetBalanceListMetaParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof getBalanceListMeta>>, TError, TData>;
    request?: SecondParameter<typeof clientMeta>;
  },
): UseQueryOptions<Awaited<ReturnType<typeof getBalanceListMeta>>, TError, TData> & { queryKey: QueryKey } => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetBalanceListMetaQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getBalanceListMeta>>> = ({ signal }) =>
    getBalanceListMeta(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions };
};

export type GetBalanceListMetaQueryResult = NonNullable<Awaited<ReturnType<typeof getBalanceListMeta>>>;
export type GetBalanceListMetaQueryError = ErrorType<HTTPValidationErrorMeta>;

export const useGetBalanceListMeta = <
  TData = Awaited<ReturnType<typeof getBalanceListMeta>>,
  TError = ErrorType<HTTPValidationErrorMeta>,
>(
  params?: GetBalanceListMetaParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof getBalanceListMeta>>, TError, TData>;
    request?: SecondParameter<typeof clientMeta>;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetBalanceListMetaQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Returns dict of balances of specified addresses for all supported tokens and blockchains
 * @summary Get balance dict
 */
export const getBalanceDictMeta = (
  params?: GetBalanceDictMetaParams,
  options?: SecondParameter<typeof clientMeta>,
  signal?: AbortSignal,
) => {
  return clientMeta<BalanceDictMeta>({ url: `/api/v2/meta/balances/dict`, method: 'get', params, signal }, options);
};

export const getGetBalanceDictMetaQueryKey = (params?: GetBalanceDictMetaParams) =>
  [`/api/v2/meta/balances/dict`, ...(params ? [params] : [])] as const;

export const getGetBalanceDictMetaQueryOptions = <
  TData = Awaited<ReturnType<typeof getBalanceDictMeta>>,
  TError = ErrorType<HTTPValidationErrorMeta>,
>(
  params?: GetBalanceDictMetaParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof getBalanceDictMeta>>, TError, TData>;
    request?: SecondParameter<typeof clientMeta>;
  },
): UseQueryOptions<Awaited<ReturnType<typeof getBalanceDictMeta>>, TError, TData> & { queryKey: QueryKey } => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetBalanceDictMetaQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getBalanceDictMeta>>> = ({ signal }) =>
    getBalanceDictMeta(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions };
};

export type GetBalanceDictMetaQueryResult = NonNullable<Awaited<ReturnType<typeof getBalanceDictMeta>>>;
export type GetBalanceDictMetaQueryError = ErrorType<HTTPValidationErrorMeta>;

export const useGetBalanceDictMeta = <
  TData = Awaited<ReturnType<typeof getBalanceDictMeta>>,
  TError = ErrorType<HTTPValidationErrorMeta>,
>(
  params?: GetBalanceDictMetaParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof getBalanceDictMeta>>, TError, TData>;
    request?: SecondParameter<typeof clientMeta>;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetBalanceDictMetaQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
};
